import os
#from synthetic_text_gen.synthetic_text_gen import synthetic_text
import sys
import json
import re
import os.path

import img_f

import pdfplumber
import numpy as np
import editdistance as ed
import matplotlib.pyplot as plt

from operator import itemgetter

# reads in provided file name and, if specified, a resolution
def read_args():
	if __name__ == "__main__":
		imageRes = 0 # if no command line argument passed, resolution is 0
		for i, arg in enumerate(sys.argv):
			if i == 1:
				fileName = arg # commandline argument specifies PDF to convert to PNG
				print("\nfile name is " + fileName)
			if i == 2:
				imageRes = int(arg)
				print("imageRes is " + str(imageRes))

	return (fileName, imageRes)


# takes PDF file and converts it to a numpy array, and saves it page by page in a .PNG file
def create_image(imageRes, pdfName, resolutionSpecified):
	with pdfplumber.open(pdfName) as pdf:
		pageCount = 0
		size = len(pdfName)
		dirName = pdfName[:size - 4] # removes .pdf file extension

		if not os.path.exists(dirName):
			os.mkdir(dirName) # if directory doesn't exist, create one to store new images

		if not resolutionSpecified:
			imageRes = 72

		# check if the images have already been generated by checking log
		logName = dirName + "/info.txt"
		alreadyGenerated = True
		if not os.path.exists(logName):
			print("creating info.txt...")
			f = open(logName, "w")
			f.write(str(imageRes))
			f.close()
			alreadyGenerated = False

		f = open(logName, "r")
		lastRes = int(f.readline())
		f.close()
		
		if not alreadyGenerated or (imageRes != lastRes and resolutionSpecified):
			f = open(logName, "w")
			generateNew = True
			f.write(str(imageRes))
			f.close()
			print("printing with resolution of " + str(imageRes))
		else:
			generateNew = False
			print("no file updates necessary! Images with resolution of " 
				+ str(lastRes) + " should already exist!")
		
		for page in pdf.pages:
			if generateNew:
				print("converting page number " + str(pageCount) + " to .png...")
				im = page.to_image(resolution=imageRes)
				im.save(dirName + "/page" + str(pageCount) + ".png", format="PNG")

			pageCount += 1

	return pageCount


# to remove lines for text containing only the text found with the '[]'
def string_match(string, search=re.compile(r'[^_ .()â€¢[\]]').search):
	return not bool(search(string))


# pulls box and field data from generated JSON file
def process_data(pdfName, pageCount):
	print("\nloading json file...")
	with open(pdfName[:len(pdfName)-4] + ".json", "r") as file:
		pdfInfo = json.load(file)
	
	fieldData = []
	i = 0
	pageHeights = []
	while i < pageCount:
		pageHeight = pdfInfo['formImage']['Pages'][i]['Height']
		pageHeights.append(pageHeight)

		for field in pdfInfo['formImage']['Pages'][i]['Fields']:
			try:
				fieldName = field['TU'].lower()
			except:
				fieldName = None
			tuple = (i, fieldName, field['x'], field['y'], field['w'], field['h'])
			fieldData.append(tuple)

		for boxset in pdfInfo['formImage']['Pages'][i]['Boxsets']:
			for box in boxset['boxes']:
				try:
					boxName = box['TU'].lower()
				except:
					boxName = None
				tuple = (i, boxName, box['x'], box['y'], box['w'], box['h'])
				fieldData.append(tuple)

		i += 1

# TODO: convert from lists to dictionaries? Indices would be much easier to understand

	return fieldData, pageHeights


# deprecated print function to make sure that all data that can be pulled from JSON is pulled...
def print_list(list):
	counter = 0
	for dim in list:
		if dim[1] != "text":
			print(str(counter) + ".) page" + str(dim[0]) + ":" + dim[1] + ": x=" + str(dim[2]) + ", y=" +
		  		str(dim[3]) + ", w=" + str(dim[4]) + ", h=" + str(dim[5]))
		else:
			print(str(counter) + ".) page" + str(dim[0]) + ", text says: " + dim[6])

		counter += 1


def plot_spacing(pageCount, textData, pdfName):
	# plot data to see distribution
	# TODO: sort data by frequency?
	# sort by page -> otherwise, we get false data comparison between pages

	i = 0
	textIndex = 0
	pageTextList = []
	textLists = []
	#print("LENGTH of textData is " + str(len(textData)))
	while i < pageCount:
		currPage = i 
		#print("currPage is " + str(currPage))
		#print("textIndex is " + str(textIndex))
		while currPage == i and textIndex < len(textData):
			currPage = textData[textIndex][0]
			if currPage == i:
				pageTextList.append(textData[textIndex])
				textIndex += 1
			else:
				break
		textLists.append(pageTextList)
		print("LIST" + str(textLists[i]))
		pageTextList.clear()
		i += 1


	print("PRINTING WITH NUMBER BASED LOOP")
	i = 0
	while i < len(textLists):
		print("LIST" + str(textLists[i]))
		i += 1
	
	print("PRINTING WITH ITERATING LOOP")
	for textList in listOfLists:
		print("Printing an item from listOfLists")
		print(textList)
	# loops through the text of each page separately and generate separate plot
	pageNum = 0
	for textList in listOfLists:
		print("PAGE " + str(pageNum) + " has " + str(len(textList)) + " elements")
		sortedTextList = sorted(textList, key=itemgetter(5))
		sortedYValueData = []
		#print(sortedTextList)
		for sortedText in sortedTextList:
			#print(sortedText[5])
			sortedYValueData.append(sortedText[5])

		#print(sortedYValueData)
		sortedSpacingData = []
		i = 0
		for text in sortedYValueData[1:]:
			# at this point, unsorted
			sortedSpacingData.append(text - sortedYValueData[i])
			i += 1

		sortedSpacingData.sort()
		# approximately 5 per interval average - maybe pass in as a variable?
		numFrequencySections = len(textList) // 5
		interval = (sortedSpacingData[len(sortedSpacingData) - 1] - sortedSpacingData[0]) / numFrequencySections
		i = 0
		currentStep = sortedSpacingData[0]
		frequencyList = [0]
		frequencyIndex = 0
		while i < len(sortedSpacingData):
			#print("frequencyList is now " + str(frequencyIndex))
			#print("currentStep is " + str(currentStep) + " and the dataPoint is " + str(sortedSpacingData[i]))
			if(sortedSpacingData[i] <= currentStep):
				frequencyList[frequencyIndex] += 1
				#print("\tfrequencyList at " + str(frequencyIndex) + " is now " + str(frequencyList[frequencyIndex]))
			# needs to iterate through again to make sure we're not adding to the wrong interval
			elif(sortedSpacingData[i] > currentStep):
				currentStep += interval
				frequencyList.append(0)
				frequencyIndex += 1
				continue
			i += 1

		i = 0
		currentStep = sortedSpacingData[0]
		intervalList = []
		while i <= numFrequencySections:
			intervalList.append(currentStep)
			currentStep += interval
			i += 1

		#print(intervalList)
		#print(frequencyList)
		
		plt.plot(intervalList, frequencyList)
		plt.xlabel("number on sorted listed")
		plt.ylabel("vertical space between closest neighbors")
		noPdfName = pdfName[:len(pdfName)-4]
		plotName = noPdfName + (noPdfName[len("examplePDFs"):]) + str(pageNum) + ".png"
		plt.savefig(plotName)
		plt.show()

		pageNum += 1


# finds and draws boxes around text entity... needs work with multiline texts
def extract_text_boxes(pdfName, pageHeights):
	print("extracting text...")
	pdf = pdfplumber.open(pdfName)
	pageNum = 0
	textData = []
	pageWidths = []
	for page in pdf.pages:
		wordList = page.extract_words()
		pageHeight = page.height
		pageWidth = page.width
		pageWidths.append(pageHeights[pageNum] * float(pageWidth / pageHeight))

		lastWord = wordList[0]
		box_x0 = lastWord['x0']
		box_x1 = lastWord['x1']
		textLine = lastWord['text']
		lastWordHeight = lastWord['bottom'] - lastWord['top']
		height = lastWordHeight
		top = lastWord['top']

		# TODO: inspect line spacing

		for word in wordList[1:]:
			lastWordHeight = lastWord['bottom'] - lastWord['top']
			wordHeight = word['bottom'] - word['top']
			if(lastWordHeight < wordHeight):
				height = wordHeight

			if float(word['x0'] - lastWord['x1']) == 0.0:
				heightsToGapRatio = float(wordHeight)
			else:
				heightsToGapRatio = float(wordHeight) / float(word['x0'] - lastWord['x1'])

			if string_match(word['text']):
				continue
			elif heightsToGapRatio > 2.3: # ratio maybe should be tweaked to better detect word spacing?
				textLine = textLine + " " + word['text']
				box_x1 = word['x1']
			else:
				boxInfo = (pageNum, (float(box_x0) / float(pageWidth)), (float(box_x1) / float(pageWidth)), 
						textLine.lower(), (float(height) / float(pageHeight)), (float(top) / float(pageHeight)))
				textData.append(boxInfo)
				box_x0 = word['x0']
				box_x1 = word['x1']
				height = word['bottom'] - word['top']
				top = word['top']
				textLine = word['text']
				
			lastWord = word

		boxInfo = (pageNum, (float(box_x0) / float(pageWidth)), (float(box_x1) / float(pageWidth)), 
				textLine.lower(), (float(height) / float(pageHeight)), (float(top) / float(pageHeight)))
		textData.append(boxInfo)
		pageNum += 1

# TODO: switch from lists to dictionaries? Indices would be much easier to understand
		
	return textData, pageWidths


# takes field and text data, along with page information, to draw bounding boxes
def draw_bounding_boxes(pageCount, pdfName, pageHeights, pageWidths, fieldData, textData):
	# plot data
	plot_spacing(pageCount, textData, pdfName)

	i = 0
	boxIndex = 0
	textIndex = 0
	while i < pageCount:
		imageName = (pdfName[:len(pdfName)-4] + "/page" + str(i) + ".png")
		img = img_f.imread(imageName,color=True)
		imageHeight = img.shape[0]
		imageWidth = img.shape[1]
		heightMultiplier = imageHeight / pageHeights[i]
		widthMultiplier = imageWidth / pageWidths[i]

		currPage = i
		while currPage == i and boxIndex < len(fieldData):
			currPage = fieldData[boxIndex][0]
			if currPage == i:
				x = fieldData[boxIndex][2] * widthMultiplier
				y = fieldData[boxIndex][3] * heightMultiplier
				w = fieldData[boxIndex][4] * widthMultiplier
				h = fieldData[boxIndex][5] * heightMultiplier 

				leftX = int(x)
				leftY = int(y)
				rightX = int(x + w)
				rightY = int(y + h)

				img_f.rectangle(img,(leftX, leftY),(rightX, rightY),color=(255,0,0),thickness=3)
			else:
				break
			boxIndex += 1

		currPage = i
		while currPage == i and textIndex < len(textData):
			currPage = textData[textIndex][0]
			if currPage == i:
				leftX = int(textData[textIndex][1] * imageWidth)
				leftY = int(textData[textIndex][5] * imageHeight)
				rightX = int(textData[textIndex][2] * imageWidth)
				rightY = int((textData[textIndex][4] * imageHeight) + leftY)

				img_f.rectangle(img,(leftX, leftY),(rightX, rightY),color=(0,220,30),thickness=3)
			else:
				break
			textIndex += 1

		editedImageName = imageName[:len(imageName)-4] + "_edited.png"
		print("writing to " + editedImageName + "...")
		img_f.imwrite(editedImageName, img)
		i += 1


# creates a numpy array image of text that can be inserted into the form, needs updating to function as intended
#def create_text(width, height):
#	generator = synthetic_text.SyntheticText("fonts", ".",line_prob=0.0,line_thickness=70,line_var=0,mean_pad=10,
#		pad=0,gaus_noise=0,gaus_std=0.0000001,blur_std=0.01,hole_prob=0.0, hole_size=400,neighbor_gap_var=0,rot=0.1, 
#		use_warp=0.0,warp_std=[1,1.4], linesAboveAndBelow=False,useBrightness=False)
#
#	widthHeightRatio = width / height
#	numChars = int(widthHeightRatio * 1.5)
#	img,text,fnt = generator.getSample(numChars)
#
#	img = 255 - (img * 255)
#	img = img_f.resize(img, (int(height), int(width)))
#	return img
	

# seeks to find the connection between text and associated fields and boxes
def field_text_relations(textData, pdfName, fieldData, pageHeights, pageWidths):
	pageEndTextCount = 0
	pageBeginTextCount = 0
	currPage = 0
	imageName = (pdfName[:len(pdfName)-4] + "/page" + str(currPage) + "_edited.png")
	img = img_f.imread(imageName,color=True)
	imageHeight = img.shape[0]
	imageWidth = img.shape[1]

	for field in fieldData:
		if field[0] != currPage:
			img_f.imwrite(imageName, img)
			currPage = field[0]
			imageName = imageName[:len(imageName)-12] + str(currPage) + "_edited.png"
			imageName = (imageName)
			img = img_f.imread(imageName,color=True)
			imageHeight = img.shape[0]
			imageWidth = img.shape[1]
			print("setting pageEndTextCount(" + str(pageEndTextCount) + ") to pageBeginTextCount(" 
				+ str(pageBeginTextCount) + ")")
			pageEndTextCount = pageBeginTextCount
		else:
			pageBeginTextCount = pageEndTextCount

		if field[1] is not None:
			pageBeginTextCount = labeled_relations(pageBeginTextCount, field, textData, currPage, img, imageName)
		elif field[1] is None:
			pageBeginTextCount = unlabeled_relations(pageHeights, pageWidths, textData, img, imageName, currPage, 
								imageHeight, imageWidth, field, pageBeginTextCount)


# helper function for 'field_text_relations' that looks at fields with titles
def labeled_relations(pageTextCount, field, textData, currPage, img, imageName):
	# calculates edit distance between field title & every text box on page,
	# keeping the text with the lowest edit distance as "minimumString"
	i = pageTextCount
	fieldName = field[1]
	minimumDist = 1000
	minimumString = "DEFAULT"
	textDataSize = len(textData)
	while i < textDataSize:
		text = textData[i]
		if currPage != text[0]:
			pageTextCount = i
			break
		editDistance = ed.eval(fieldName, text[3])
		if editDistance < minimumDist:
			minimumDist = editDistance
			minimumString = text[3]
		i += 1

	# finds phrases that have a word in common at a time with field title;
	# the total number is also tracked
	if minimumDist != 0:
		words = fieldName.split(" ")
		matchList = []
		i = pageTextCount
		j = 0
		while i < textDataSize:
			text = textData[i]
			#print("currPage is " + str(currPage) + " & textPage is " + str(text[0]) + 
			#	" when i is " + str(i) + "; fieldPage is " + str(field[0]))
			if currPage != text[0]:
				pageTextCount = i
				break
			matchList.append([i, 0])
			for word in words:
				if word == "":
					continue
				if word in text[3]:
					matchList[j][1] += 1
			i += 1
			j += 1

		# checks matching phrases for proximity
		#field_proximity_check(field, textData, matchList, img, imageName)

		# reduces matching phrases to the phrase with the most words
		refinedMatchList = []
		j = 0
		match = 0
		for x in matchList:
			if x[1] < match:
				continue
			if x[1] > match:
				refinedMatchList.clear()
				match = x[1]
			refinedMatchList.append(x[0])
			j += 1
				
		if len(refinedMatchList) == 1:
			matchIndx = refinedMatchList[0]
			minimumString = textData[matchIndx][3]
			print("CLOSE match: '" + fieldName + "' & '" + minimumString + "'")
		elif len(refinedMatchList) == 0:
			print("'" + fieldName + "' & '" + minimumString + "' w/ distance " + str(minimumDist))
		elif len(refinedMatchList) > 1:
			minimumDist = 1000
			minimumString = ""
			for match in refinedMatchList:
				editDistance = ed.eval(fieldName, textData[match][3])
				if editDistance < minimumDist:
					minimumDist = editDistance
					minimumString = textData[match][3]
			print("'" + fieldName + "' & '" + minimumString + "' w/ distance " + str(minimumDist))

	else:
		print("perfect match: '" + fieldName + "' & '" + minimumString + "'")

	return pageTextCount


# helper function for 'field_text_relations' that looks at fields without titles
def unlabeled_relations(pageHeights, pageWidths, textData, img, imageName, currPage, 
						imageHeight, imageWidth, field, pageBeginTextCount):
	pageHeight = pageHeights[currPage]	
	pageWidth = pageWidths[currPage]
	heightMultiplier = imageHeight / pageHeight
	widthMultiplier = imageWidth / pageWidth

	field_x = int(field[2] * widthMultiplier)
	field_y = int(field[3] * heightMultiplier)
	field_w = int(field[4] * widthMultiplier)
	field_h = int(field[5] * heightMultiplier)

	leftX = int(field_x)
	leftY = int(field_y)
	rightX = int(field_x + field_w)
	rightY = int(field_y + field_h)

	for text in textData:
		# TEXT INFO (ratios) -> [0]:pageNum, [1]:x0, [2]:x1, [3]:textLine, [4]:height, [5]:top
		# BOX INFO -> [0]:pageNum, [1]:boxName, [2]:x, [3]:y, [4]:w, [5]:h
		if text[0] == field[0]:
			pageBeginTextCount += 1

			text_x0 = int(text[1] * imageWidth)
			text_x1 = int(text[2] * imageWidth)
			text_h = int(text[4] * imageHeight)
			text_top = int(text[5] * imageHeight)

			leftMargin = (field_x - text_x1) / imageWidth
			rightMargin = (text_x0 - (field_x + field_w)) / imageWidth
			topMargin = (field_y - (text_top + text_h)) / imageHeight
			bottomMargin = (text_top - (field_y + field_h)) / imageHeight

			# DRAWS A DIFFERENT COLORED BOX AROUND UNASSOCIATED FIELDS (just so I can figure out margins and such)
			img_f.rectangle(img,(leftX, leftY),(rightX, rightY),color=(0,0,255),thickness=5)

			isRight = True
			isLeft = True
			isAbove = True
			isBelow = True

			# RADIO GROUPS -> NEED TO BE PRESERVED SO ONLY ONE GETS FILLED OUT, ONE HEADER? -> all get same header, but not 
			# individual label
			#print("FIELD: x=" + str(field_x) + ", y=" + str(field_y) + ", w=" + str(field_w) + ", h=" + str(field_h))
			#print("TEXT: x0=" + str(text_x0) + ", x1=" + str(text_x1) + ", h=" + str(text_h) + ", top=" + str(text_top))
			#print("LEFT:" + str(leftMargin) + ", RIGHT:" + str(rightMargin) + 
			#	", TOP:" + str(topMargin) + ", BOTTOM:" + str(bottomMargin))
			#print(" >TEXT: '" + text[3] + "'\n")

			if(rightMargin < 0):
				isRight = False
			if(leftMargin < 0):
				isLeft = False
			if(topMargin < 0):
				isAbove = False
			if(bottomMargin < 0):
				isBelow = False

	img_f.imwrite(imageName, img)
	return pageBeginTextCount


def field_proximity_check(field, textData, matchList, img, imageName):
	# TODO: if a text with no matches lays in between two, how do I merge that into one complete text?
	imageHeight = img.shape[0]
	imageWidth = img.shape[1]
	fieldName = field[1]
	# matchList contains all text items. If there were matches, matchList[1] will contain # of matches
	prunedList = []
	maxMatch = 0
	maxMatchList = []
	i = 0
	for match in matchList:
		matchValue = match[1]
		if matchValue > 0:
			prunedList.append(match)

		if matchValue < maxMatch:
			continue
		elif matchValue > maxMatch:
			for x in maxMatchList:
				# readds previous matches to matchList if superseded by a better match
				matchList.append(x)
			maxMatch = matchValue
			maxMatchList.clear()
		# ensures that there is no comparison of `maxMatch`es with themselves by removing it from `matchList`
		del matchList[i]
		maxMatchList.append(match)

	boxCombine = []
	for match in prunedList:
		# text is a string with at least one word contained within fieldName
		# for example, if fieldName is "date of birth", `text` contains some combination of 1 or more 
		# "date", "of", and "birth"
		text = textData[match[0]]
		text_x0 = int(text[1] * imageWidth)
		text_x1 = int(text[2] * imageWidth)
		text_h = int(text[4] * imageHeight)
		text_top = int(text[5] * imageHeight)

		# put this loop on the outside
		for maxMatch in maxMatchList:
			maxText = textData[maxMatch[0]]
			maxText_x0 = int(text[1] * imageWidth)
			maxText_x1 = int(text[2] * imageWidth)
			maxText_h = int(text[4] * imageHeight)
			maxText_top = int(text[5] * imageHeight)

			isLeft = False
			isRight = False
			isAbove = False
			isBelow = False
			isCentered = False

			# SPACING CONSIDERATION - probably no more than double spacing

			# tolerances as a ratio of page size
			x0_margin = abs(text_x0 - maxText_x0) / imageWidth
			x1_margin = abs(text_x1 - maxText_x1) / imageWidth
			bottom_margin = abs((text_top + text_h) - (maxText_top + maxText_h)) / imageHeight
			top_margin = abs(text_top - maxText_top) / imageHeight
			center_diff = abs((text_x1 - text_x0) - (maxText_x1 - maxText_x0)) / imageWidth
			# Do I need to compare centering as related to the length of the text as well? What if right or left aligned?

			# fine tuning margins - do I need to account for text height? Probably so (bigger text overfits, smaller text underfits)
			if (x0_margin < 0.1):
				isLeft = True
			if (x1_margin < 0.1):
				isRight = True
			if (bottom_margin < 0.1):
				isBelow = True
			if (top_margin < 0.1):
				isAbove = True
			if (center_diff < 0.1):
				isCenter = True
			else:
				boxCombine.append(text)

			# TODO: cases for what these margins mean! What is close enough? Too far? What are the rules? Tolerances?

	# TODO: put this in it's own function so that there is only one write function for faster performance
	maxLeftX = 0
	maxLeftY = 0
	maxRightX = 0
	maxRightY = 0
	#maxTextLine -> for future parsing? not sure if this is important to store
	
	# combine
	#for match in textData:


	for text in boxCombine:
		leftX = int(text[1] * imageWidth)
		leftY = int(text[5] * imageHeight)
		rightX = int(text[2] * imageWidth)
		rightY = int((text[4] * imageHeight) + leftY)
		# TODO: case of initial, will never change because will always be 0 -> must assign first time through
		if leftX < maxLeftX:
			maxLeftX = leftX
		if leftY < maxLeftY:
			maxLeftX = leftY
		if rightX > maxRightX:
			maxRightX = rightX
		if rightY > maxRightY:
			maxRightY = rightY
		
	# TODO: using the MAX dimensions for combining boxes doesn't work - need to know what I'm looking at to see
	# if combining actually makes sense for the given scenario
	img_f.rectangle(img,(maxLeftX, maxLeftY),(maxRightX, maxRightY),color=(255,0,255),thickness=3)

	img_f.imwrite(imageName, img)


def text_vertical_merge():
	print("merging text aligned vertically")


def main():
	args = read_args()
	pdfName = args[0]
	imageRes = args[1]
	resolutionSpecified = True
	if imageRes == 0:
		print("no resolution specified")
		resolutionSpecified = False

	pageCount = create_image(imageRes, pdfName, resolutionSpecified)
	fieldData, pageHeights = process_data(pdfName, pageCount)
	textData, pageWidths = extract_text_boxes(pdfName, pageHeights)
	draw_bounding_boxes(pageCount, pdfName, pageHeights, pageWidths, fieldData, textData)
	field_text_relations(textData, pdfName, fieldData, pageHeights, pageWidths)


if __name__ == "__main__":
    main()